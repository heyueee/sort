# sort
常规版本排序 实现选择排序、归并排序、快速排序、希尔排序、基数排序
一、实现这五种排序并分析
1.选择排序
算法分析：
    每一趟排序从尚未排序的序列中选出最小的元素，(先假设第一个元素是最小的，遍历后面的元素，不断记录更小的元素下标，即可得到一趟遍历中最小元素)然后与该未排序序列的第一个元素交换位置，确定该元素的位置，如此重复直到所有元素排序完成。
    时间复杂度分析：一趟排序的比较次数是0(n)，重复n-1趟，所以时间复杂度是0(n^2)。
    
主要代码
![image](https://user-images.githubusercontent.com/117704533/200477523-b2099e10-83cc-4cf6-8ea8-7f1584f4da41.png)

2.归并排序
算法分析
    先将最初长度为n的待排序序列从中间划分成两个子序列，再递归划分左右两个子序列，形成 n个长度为1的有序子序列 。再将相邻的两个子序列两两合并，形成有序序列，如此重复最后得到长度为n的有序序列。
   一趟合并的过程是借助一个临时数组，比较待合并的左右两个序列的第一个元素大小，将较小的赋值给临时数组，直到两个子序列的元素都完成合并。：
    归并排序的时间复杂度为归并的趟数与每一趟归并的时间的复杂度的乘积。子算法merge合并的时间复杂度为0(n),趟数为log₂n ,故算法复杂度为0(nlogn)。
   
主要代码
![image](https://user-images.githubusercontent.com/117704533/200478942-e0ccff7b-4459-47d2-bc5e-d09064ff88b0.png)
![image](https://user-images.githubusercontent.com/117704533/200478826-043ad129-e05e-430c-816e-5cf5a9bdc6a8.png)

3.快速排序
算法分析

主要代码
![image](https://user-images.githubusercontent.com/117704533/200479083-9e9fbedd-f06e-4dc8-9ad2-52ecad3aca26.png)

4.希尔排序
5.基数排序
算法分析
    基数排序的基本思想是：先将待排序序列按个位数排好，然后按顺序复制回原数组；再按十位排序好，再按顺序复制回原数组；依次类推，按百位、千位，排序的趟数就是最大数的位数。
    具体实现借助桶，九个桶分别对应的是0~9十个数字。桶里装的不是数据本身，而是桶编号对应的数据个数， 然后累加可得数据排第几。
    时间复杂度分析：排序的趟数是最大数的位数d,而每趟排序的时间复杂度的为O(n),所以基数排序时间复杂度为O(dn)。
主要代码
    ![image](https://user-images.githubusercontent.com/117704533/200480624-61d5dc7b-6e32-415d-86aa-d03bdf8887fb.png)
 
 二、分析其在不同规模的输入下单机性能变化情况
 生成不同长度的随机数组，计时，比较这五种排序算法随机实验10次的平均运行时间。
主要代码
 ![image](https://user-images.githubusercontent.com/117704533/200481162-7805595d-ea2e-4080-a7b0-ad26dbd332b5.png)
 ![image](https://user-images.githubusercontent.com/117704533/200481254-05a65f4a-29a4-432f-b7d6-fde040d2c16f.png)
运行结果
 ![image](https://user-images.githubusercontent.com/117704533/200481463-112840b7-6946-4d56-9ee3-efe504a0cd12.png)
性能分析
 运行时间从低到高排序：基数排序<归并排序和快速排序（一个数量级）<希尔排序<选择排序
 在输入规模在1000及以下时，五种算法差别不大，而随着输入规模的增大..........
 

 

 

 
    


    

 
    
    
    




